
import { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';

// Base directory for AI Knowledge Base
// CHANGED: Use persistent 'data' directory outside of 'dist' to survive deployments
// FORCE 'data' usage even in dev to unify source of truth
const KNOWLEDGE_BASE_DIR = path.join(__dirname, '../../data/ai_knowledge_base');

// Subdirectories allowed
const AGENT_CATEGORIES = ['agents_god_mode', 'agents_public', 'agents_internal'];
const STANDARD_FOLDERS = ['instructions', 'information', 'core'];
const ALLOWED_FOLDERS = [...AGENT_CATEGORIES, ...STANDARD_FOLDERS];

// Helper to extract identifier from identity.md (e.g. "8740")
const getAgentIdentifier = (content: string): string => {
    const match = content.match(/\[(\d{4})\]/);
    return match ? match[1] : '';
};

/**
 * LIST FILES
 * Returns folders and files structure
 */
export const listKnowledgeFiles = async (req: Request, res: Response) => {
    try {
        const structure: any = {};
        console.log(`[KnowledgeDebug] LIST Request. BaseDir: ${KNOWLEDGE_BASE_DIR}`);

        for (const folder of ALLOWED_FOLDERS) {
            const folderPath = path.join(KNOWLEDGE_BASE_DIR, folder);

            // Create folder if not exists
            if (!fs.existsSync(folderPath)) {
                fs.mkdirSync(folderPath, { recursive: true });
            }

            if (AGENT_CATEGORIES.includes(folder)) {
                // Read active agent from config.json if it exists
                let activeAgent = '';
                const configPath = path.join(folderPath, 'config.json');
                if (fs.existsSync(configPath)) {
                    try {
                        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
                        activeAgent = config.activeAgent || '';
                    } catch (e) {
                        console.error(`Error reading config for ${folder}:`, e);
                    }
                }

                // For agents categories, list directories (the agents themselves) and their files
                const agents = fs.readdirSync(folderPath, { withFileTypes: true })
                    .filter(dirent => dirent.isDirectory())
                    .map(dirent => {
                        const agentName = dirent.name;
                        const agentPath = path.join(folderPath, agentName);
                        const files = fs.readdirSync(agentPath)
                            .filter(f => f.endsWith('.md'))
                            .map(f => {
                                const content = fs.readFileSync(path.join(agentPath, f), 'utf-8');
                                return {
                                    name: f,
                                    path: `${folder}/${agentName}/${f}`,
                                    size: content.length
                                };
                            });

                        const hasIdentity = files.some(f => f.name === 'identity.md');
                        const isActive = activeAgent === agentName;

                        return {
                            name: agentName,
                            type: 'agent',
                            hasIdentity,
                            isActive,
                            files: files
                        };
                    });
                structure[folder] = agents;
                structure[`${folder}_config`] = { activeAgent };
            } else {
                // Standard folders (flat files)
                const files = fs.readdirSync(folderPath)
                    .filter(file => file.endsWith('.md') || file.endsWith('.json') || file.endsWith('.yaml'))
                    .map(file => ({
                        name: file,
                        path: `${folder}/${file}`
                    }));
                structure[folder] = files;
            }
        }

        res.json({
            success: true,
            data: structure
        });

    } catch (error: any) {
        console.error('[KnowledgeController] List error:', error);
        res.status(500).json({ success: false, error: 'Failed to list knowledge files' });
    }
};

/**
 * READ FILE
 */
export const readKnowledgeFile = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;

        let safePath = '';
        if (AGENT_CATEGORIES.includes(folder)) {
            const subPath = (req.query.path as string) || req.params.filename;
            if (!subPath) return res.status(400).json({ error: 'Subpath is required for agents' });

            // Remove folder prefix if present (e.g. agents_god_mode/admin_sidekick/identity.md)
            const cleanSubPath = subPath.startsWith(folder + '/') ? subPath.replace(folder + '/', '') : subPath;
            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, cleanSubPath);
        } else {
            if (!ALLOWED_FOLDERS.includes(folder)) return res.status(400).json({ error: 'Invalid folder' });
            const subPath = req.params[0] || req.params.filename || (req.query.path as string);
            if (!subPath) return res.status(400).json({ error: 'Filename is required' });

            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, path.basename(subPath));
        }

        // Security check
        if (!safePath.startsWith(KNOWLEDGE_BASE_DIR)) {
            return res.status(403).json({ error: 'Access denied' });
        }

        if (!fs.existsSync(safePath)) {
            return res.status(404).json({ success: false, error: 'File not found' });
        }

        // Auto-resolve directory to identity.md
        if (fs.lstatSync(safePath).isDirectory()) {
            const identityPath = path.join(safePath, 'identity.md');
            if (fs.existsSync(identityPath)) {
                safePath = identityPath;
            } else {
                return res.status(400).json({ error: 'Cannot read directory' });
            }
        }

        const content = fs.readFileSync(safePath, 'utf-8');
        res.json({ success: true, data: { content } });

    } catch (error: any) {
        console.error('[KnowledgeController] Read error:', error);
        res.status(500).json({ success: false, error: 'Failed to read file' });
    }
};

/**
 * SAVE FILE
 */
export const saveKnowledgeFile = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;
        const filename = req.params.filename || req.params[0] || (req.query.path as string) || req.body.path;
        const { content } = req.body;

        if (!filename) return res.status(400).json({ error: 'Filename is required' });
        if (content === undefined) return res.status(400).json({ error: 'Content required' });

        let safePath = '';
        if (AGENT_CATEGORIES.includes(folder)) {
            const subPath = (req.query.path as string) || req.body.path || req.params.filename;
            if (!subPath) return res.status(400).json({ error: 'Subpath is required for agents' });
            const cleanSubPath = subPath.startsWith(folder + '/') ? subPath.replace(folder + '/', '') : subPath;
            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, cleanSubPath);
        } else {
            if (!ALLOWED_FOLDERS.includes(folder)) return res.status(400).json({ error: 'Invalid folder' });
            const subPath = (req.query.path as string) || req.body.path || req.params.filename;
            if (!subPath) return res.status(400).json({ error: 'Filename is required' });
            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, path.basename(subPath));
        }

        if (!safePath.startsWith(KNOWLEDGE_BASE_DIR)) {
            return res.status(403).json({ error: 'Access denied' });
        }

        const parentDir = path.dirname(safePath);
        if (!fs.existsSync(parentDir)) {
            fs.mkdirSync(parentDir, { recursive: true });
        }

        fs.writeFileSync(safePath, content, 'utf-8');
        res.json({ success: true, message: 'Saved' });

    } catch (error: any) {
        console.error('[KnowledgeController] Save error:', error);
        res.status(500).json({ success: false, error: 'Failed to save file' });
    }
};

/**
 * UPLOAD AND PROCESS FILE
 */
export const uploadKnowledgeFile = async (req: Request, res: Response) => {
    try {
        const { folder, agentName } = req.body;
        const file = req.file;

        if (!file) return res.status(400).json({ error: 'No file uploaded' });

        let destFolder = '';
        if (AGENT_CATEGORIES.includes(folder)) {
            if (!agentName) return res.status(400).json({ error: 'Agent name required for agent folder' });
            destFolder = path.join(KNOWLEDGE_BASE_DIR, folder, agentName);
        } else {
            if (!ALLOWED_FOLDERS.includes(folder)) return res.status(400).json({ error: 'Invalid folder' });
            destFolder = path.join(KNOWLEDGE_BASE_DIR, folder);
        }

        if (!fs.existsSync(destFolder)) {
            fs.mkdirSync(destFolder, { recursive: true });
        }

        const originalName = file.originalname;
        const extension = path.extname(originalName).toLowerCase();
        const baseName = path.basename(originalName, extension);
        const mdFilename = `${baseName}.md`;
        const mdPath = path.join(destFolder, mdFilename);

        let extractedContent = '';
        const { AIService } = require('../services/aiService');
        const aiService = AIService.getInstance();

        if (extension === '.pdf' || ['.jpg', '.jpeg', '.png'].includes(extension)) {
            const prompt = extension === '.pdf'
                ? `Analiza este documento PDF y transcribe todo su contenido a formato Markdown.`
                : `Analiza esta imagen y extrae toda la informaciÃ³n relevante en formato Markdown.`;

            const analysis = await aiService.analyzeImage(prompt, file.buffer, file.mimetype);
            extractedContent = extension === '.pdf'
                ? `# DOCUMENTO EXTRAIDO: ${originalName}\n\n${analysis}`
                : `# ANALISIS DE IMAGEN: ${originalName}\n\n${analysis}`;
        } else {
            return res.status(400).json({ error: 'Unsupported file type' });
        }

        fs.writeFileSync(mdPath, extractedContent, 'utf-8');

        res.json({
            success: true,
            data: {
                originalName,
                extractedFile: mdFilename,
                path: AGENT_CATEGORIES.includes(folder) ? `${folder}/${agentName}/${mdFilename}` : `${folder}/${mdFilename}`
            }
        });

    } catch (error: any) {
        console.error('[KnowledgeController] Upload error:', error);
        res.status(500).json({ success: false, error: 'Failed to process file' });
    }
};

/**
 * DELETE FILE
 */
export const deleteKnowledgeFile = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;
        const subPath = (req.query.path as string) || req.params.filename;

        if (!subPath) return res.status(400).json({ error: 'Filename is required' });

        let safePath = '';
        if (AGENT_CATEGORIES.includes(folder)) {
            const cleanSubPath = subPath.startsWith(folder + '/') ? subPath.replace(folder + '/', '') : subPath;
            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, cleanSubPath);
        } else {
            if (!ALLOWED_FOLDERS.includes(folder)) return res.status(400).json({ error: 'Invalid folder' });
            safePath = path.join(KNOWLEDGE_BASE_DIR, folder, path.basename(subPath));
        }
        if (!safePath.startsWith(KNOWLEDGE_BASE_DIR)) {
            return res.status(403).json({ error: 'Access denied' });
        }

        if (!fs.existsSync(safePath)) {
            return res.status(404).json({ error: 'File not found' });
        }

        fs.unlinkSync(safePath);
        res.json({ success: true, message: 'Deleted' });

    } catch (error: any) {
        console.error('[KnowledgeController] Delete error:', error);
        res.status(500).json({ success: false, error: 'Failed to delete file' });
    }
};

/**
 * SET ACTIVE AGENT
 */
export const setActiveAgent = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;
        const { agentName } = req.body;

        if (!AGENT_CATEGORIES.includes(folder)) {
            return res.status(400).json({ error: 'Invalid agent category' });
        }

        const categoryPath = path.join(KNOWLEDGE_BASE_DIR, folder);
        const configPath = path.join(categoryPath, 'config.json');

        const config = fs.existsSync(configPath)
            ? JSON.parse(fs.readFileSync(configPath, 'utf-8'))
            : {};

        config.activeAgent = agentName;
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

        res.json({ success: true, message: `Active agent set to ${agentName}` });
    } catch (error: any) {
        console.error('[KnowledgeController] SetActive error:', error);
        res.status(500).json({ success: false, error: 'Failed to set active agent' });
    }
};

/**
 * CREATE NEW AGENT
 */
export const createNewAgent = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;
        const { agentName } = req.body;

        if (!AGENT_CATEGORIES.includes(folder)) {
            return res.status(400).json({ error: 'Invalid agent category' });
        }

        if (!agentName) return res.status(400).json({ error: 'Agent name is required' });

        const agentDir = path.join(KNOWLEDGE_BASE_DIR, folder, agentName.toLowerCase().replace(/\s+/g, '_'));

        if (fs.existsSync(agentDir)) {
            return res.status(400).json({ error: 'Agent already exists' });
        }

        fs.mkdirSync(agentDir, { recursive: true });
        const identityPath = path.join(agentDir, 'identity.md');
        const defaultContent = `# SYSTEM ROLE: ${agentName}\n\n[8740] Identity description goes here...`;
        fs.writeFileSync(identityPath, defaultContent);

        res.json({ success: true, data: { name: path.basename(agentDir), path: `${folder}/${path.basename(agentDir)}` } });
    } catch (error: any) {
        console.error('[KnowledgeController] CreateAgent error:', error);
        res.status(500).json({ success: false, error: 'Failed to create agent' });
    }
};

/**
 * MARK AS INSTRUCTIVE
 * Renames a file to identity.md
 */
export const markAsInstructive = async (req: Request, res: Response) => {
    try {
        const { folder } = req.params;
        const { path: subPath } = req.body;

        if (!AGENT_CATEGORIES.includes(folder)) {
            return res.status(400).json({ error: 'Invalid agent category' });
        }

        if (!subPath) return res.status(400).json({ error: 'Source path is required' });

        const cleanSubPath = subPath.startsWith(folder + '/') ? subPath.replace(folder + '/', '') : subPath;
        const sourcePath = path.join(KNOWLEDGE_BASE_DIR, folder, cleanSubPath);
        const agentDir = path.dirname(sourcePath);
        const targetPath = path.join(agentDir, 'identity.md');

        if (!fs.existsSync(sourcePath)) {
            return res.status(404).json({ error: 'Source file not found' });
        }

        // If target exists and is different from source, backup it
        if (fs.existsSync(targetPath) && sourcePath !== targetPath) {
            const backupPath = path.join(agentDir, `identity_backup_${Date.now()}.md`);
            fs.renameSync(targetPath, backupPath);
        }

        // Rename source to identity.md
        if (sourcePath !== targetPath) {
            fs.renameSync(sourcePath, targetPath);
        }

        res.json({ success: true, message: 'File is now the main instructive' });
    } catch (error: any) {
        console.error('[KnowledgeController] MarkInstructive error:', error);
        res.status(500).json({ success: false, error: 'Failed to mark as instructive' });
    }
};

export const getToolsRegistry = async (req: Request, res: Response): Promise<void> => {
    try {
        const registryPath = path.join(KNOWLEDGE_BASE_DIR, 'core', 'tools_registry.json');
        if (fs.existsSync(registryPath)) {
            const data = fs.readFileSync(registryPath, 'utf-8');
            res.json({ success: true, data: JSON.parse(data) });
        } else {
            res.json({ success: true, data: [] });
        }
    } catch (error: any) {
        console.error('[KnowledgeController] getToolsRegistry error:', error.message);
        res.status(500).json({ success: false, error: 'Error al cargar el registro de herramientas' });
    }
};
